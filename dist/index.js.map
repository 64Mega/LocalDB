{"mappings":"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","sources":["src/LocalDB.ts","src/DBTable.ts"],"sourcesContent":["/**\r\n * LocalDB - uses LocalStorage to provide a basic datastore that\r\n * utilizes some features that are similar to real Database implementations.\r\n * Useful for scaffolding something out that you're going to replace with actual DB\r\n * connections later, or for creating a quick storage system for tools and/or PWAs.\r\n */\r\n\r\nimport { DBRow } from './DBRow';\r\nimport { DBStorageObject } from './DBStorageObject';\r\n\r\nclass LocalDB {\r\n    private _tableName: string = 'default';\r\n\r\n    private _storage: DBStorageObject = {\r\n        rows: [],\r\n        _idgen: 1,\r\n    };\r\n\r\n    public get TableName(): string {\r\n        return this._tableName;\r\n    }\r\n\r\n    constructor(tableName: string) {\r\n        console.info('Initializing LocalDB/' + tableName);\r\n        this._tableName = tableName;\r\n        this.ReadDB(true);\r\n    }\r\n\r\n    // Public Methods\r\n    async Get(): Promise<DBRow[]> {\r\n        await this.ReadDB();\r\n        const rows = this._storage.rows.filter((x) => !x.isDeleted);\r\n        return Promise.resolve(rows);\r\n    }\r\n\r\n    async GetById(id: number): Promise<DBRow> {\r\n        await this.ReadDB();\r\n        const row = this._storage.rows.find((x) => x.id === id);\r\n        return Promise.resolve(row);\r\n    }\r\n\r\n    async Insert(row: any): Promise<DBRow> {\r\n        await this.ReadDB();\r\n        const id = await this.GenerateID();\r\n        const dbRow = {\r\n            id,\r\n            ...row,\r\n        };\r\n\r\n        this._storage.rows.push(dbRow);\r\n        await this.WriteDB();\r\n\r\n        return Promise.resolve(dbRow);\r\n    }\r\n\r\n    async Update(row: DBRow): Promise<DBRow> {\r\n        await this.ReadDB();\r\n        let updatedRow = null;\r\n        const index = this._storage.rows.findIndex((x) => x.id === row.id);\r\n        if (index >= 0) {\r\n            let oldRow = this._storage.rows[index];\r\n            this._storage.rows[index] = { ...oldRow, ...row };\r\n            await this.WriteDB();\r\n            return Promise.resolve(this._storage.rows[index]);\r\n        } else {\r\n            throw new Error(\r\n                `Matching id '${row.id}' not found in ${this.TableName} (LocalDB->Update).`\r\n            );\r\n        }\r\n    }\r\n\r\n    async Undelete(id: number): Promise<DBRow> {\r\n        await this.ReadDB();\r\n        const index = this._storage.rows.findIndex((x) => x.id === id);\r\n\r\n        if (index >= 0) {\r\n            this._storage.rows[index].isDeleted = undefined;\r\n            await this.WriteDB();\r\n            return Promise.resolve(this._storage.rows[index]);\r\n        } else {\r\n            throw new Error(\r\n                `Matching id '${id}' not found in ${this.TableName} (LocalDB->Undelete).`\r\n            );\r\n        }\r\n    }\r\n\r\n    async DeleteById(id: number, hardDelete: boolean = true): Promise<boolean> {\r\n        await this.ReadDB();\r\n        const index = this._storage.rows.findIndex((x) => x.id === id);\r\n        if (index >= 0) {\r\n            if (hardDelete) {\r\n                this._storage.rows.splice(index, 1);\r\n            } else {\r\n                this._storage.rows[index].isDeleted = true;\r\n            }\r\n            await this.WriteDB();\r\n            return Promise.resolve(true);\r\n        }\r\n\r\n        return Promise.resolve(false);\r\n    }\r\n\r\n    async DeleteRow(row: DBRow, hardDelete: boolean = true): Promise<boolean> {\r\n        return await this.DeleteById(row.id, hardDelete);\r\n    }\r\n\r\n    async Sort(\r\n        sortFunction?: (a: DBRow, b: DBRow) => number\r\n    ): Promise<LocalDB> {\r\n        await this.ReadDB();\r\n        this._storage.rows.sort(sortFunction);\r\n        await this.WriteDB();\r\n        return Promise.resolve(this);\r\n    }\r\n\r\n    async DeleteEntireDB() {\r\n        this._storage._idgen = 1;\r\n        this._storage.rows = [];\r\n        await this.WriteDB();\r\n    }\r\n\r\n    // Internal Methods\r\n    private async ReadDB(createIfNotExists: boolean = false): Promise<boolean> {\r\n        return new Promise(async (resolve, reject) => {\r\n            console.info('LocalDB: Reading from ' + this.TableName);\r\n            const strStorageObject = localStorage.getItem(this.TableName);\r\n            if (strStorageObject !== null) {\r\n                this._storage = JSON.parse(strStorageObject);\r\n                await this.WriteDB();\r\n                resolve(true);\r\n            } else {\r\n                if (createIfNotExists) {\r\n                    resolve(await this.WriteDB());\r\n                } else {\r\n                    reject(`Table ${this.TableName} does not exist!`);\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    private async WriteDB(): Promise<any> {\r\n        return new Promise((resolve) => {\r\n            const json = JSON.stringify(this._storage);\r\n            console.info('LocalDB: Writing to ' + this.TableName);\r\n            localStorage.setItem(this.TableName, json);\r\n            resolve(true);\r\n        });\r\n    }\r\n\r\n    private async GenerateID(): Promise<number> {\r\n        await this.ReadDB();\r\n        const id = this._storage._idgen++;\r\n        await this.WriteDB();\r\n        return Promise.resolve(id);\r\n    }\r\n}\r\n\r\nexport { LocalDB };\r\n","/**\r\n * Table Class Type\r\n * Derive your table models from this class and use it to access your data.\r\n */\r\n\r\nimport { DBRow } from './DBRow';\r\nimport { LocalDB } from './LocalDB';\r\n\r\nclass DBTable<RowModel extends DBRow> {\r\n    protected _db: LocalDB = null;\r\n\r\n    constructor(tableName: string) {\r\n        this._db = new LocalDB(tableName);\r\n    }\r\n\r\n    async GetByID(id: number): Promise<RowModel> {\r\n        return (await this._db.GetById(id)) as RowModel;\r\n    }\r\n\r\n    async GetAll(): Promise<RowModel[]> {\r\n        return (await this._db.Get()) as RowModel[];\r\n    }\r\n\r\n    async Insert(row: RowModel): Promise<RowModel> {\r\n        const res = (await this._db.Insert(row)) as RowModel;\r\n        return Promise.resolve(res);\r\n    }\r\n\r\n    async DeleteRow(row: RowModel): Promise<boolean> {\r\n        return await this._db.DeleteRow(row);\r\n    }\r\n\r\n    async DeleteById(id: number): Promise<boolean> {\r\n        return await this._db.DeleteById(id);\r\n    }\r\n\r\n    async Update(row: RowModel): Promise<RowModel> {\r\n        if (row.id) {\r\n            return (await this._db.Update(row)) as RowModel;\r\n        } else {\r\n            // Create if doesn't exist\r\n            return await this.Insert(row);\r\n        }\r\n    }\r\n\r\n    protected async SortData(): Promise<void> {\r\n        await this._db.Sort((a: DBRow, b: DBRow) => {\r\n            if (a.id < b.id) return -1;\r\n            if (a.id > b.id) return 1;\r\n            return 0;\r\n        });\r\n    }\r\n\r\n    async ReplaceData(\r\n        newData: RowModel[],\r\n        confirm: boolean = false\r\n    ): Promise<boolean> {\r\n        if (confirm) {\r\n            await this._db.DeleteEntireDB();\r\n            newData.forEach(async (row) => {\r\n                await this.Insert(row);\r\n            });\r\n            await this.SortData();\r\n            return Promise.resolve(true);\r\n        }\r\n\r\n        return Promise.resolve(false);\r\n    }\r\n\r\n    async MergeData(\r\n        newData: RowModel[],\r\n        confirm: boolean = false\r\n    ): Promise<boolean> {\r\n        if (confirm) {\r\n            newData.forEach(async (row) => {\r\n                if (row.id) {\r\n                    delete row.id;\r\n                }\r\n                await this.Insert(row);\r\n            });\r\n            await this.SortData();\r\n            return Promise.resolve(true);\r\n        }\r\n        return Promise.resolve(false);\r\n    }\r\n\r\n    async DeleteAll(areYouSure: boolean = false): Promise<boolean> {\r\n        if (areYouSure) {\r\n            this._db.DeleteEntireDB();\r\n            return Promise.resolve(true);\r\n        }\r\n        return Promise.resolve(false);\r\n    }\r\n}\r\n\r\nexport { DBTable };\r\n"],"names":["$7c2fc7a83a2df836d2e2738880686d1d$export$88201cbba478dc0e","_tableName","tableName","_storage","rows","_idgen","console","info","ReadDB","this","filter","x","isDeleted","Promise","resolve","id","row","find","dbRow","GenerateID","push","WriteDB","index","findIndex","oldRow","Error","TableName","undefined","hardDelete","splice","DeleteById","sortFunction","sort","createIfNotExists","async","reject","strStorageObject","localStorage","getItem","JSON","parse","json","stringify","setItem","$ae8cec7870b4c9d69e8f0ae825314284$export$75f2e07b24fbb3c5","_db","GetById","Get","res","Insert","DeleteRow","Update","Sort","a","b","newData","confirm","DeleteEntireDB","forEach","SortData","areYouSure"],"version":3,"file":"index.js.map"}