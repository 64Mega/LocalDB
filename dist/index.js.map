{"mappings":"uPA2FAA,sBAhFkBC,qBACSC,IAAIC,QAAQF,oCAIZC,IAAIE,mBAGdC,SACHC,QAAGC,KAAeL,IAAIM,OAAOH,UAC5BI,QAAQC,QAAQJ,mBAGXD,qBACMH,IAAIS,UAAUN,oBAGnBJ,qBACKC,IAAIU,WAAWX,gBAGxBI,UACLA,EAAIJ,SAAEM,KACaL,IAAIW,OAAOR,cAGZG,OAAOH,+BAKlBH,IAAIY,MAAI,CAAEC,EAAUC,IACvBD,EAAEd,GAAKe,EAAEf,IAAW,EACpBc,EAAEd,GAAKe,EAAEf,GAAW,EACjB,sBAKXgB,EACAC,GAAmB,UAEfA,cACWhB,IAAIiB,iBACfF,EAAQG,SAAOC,MAAQhB,eACRG,OAAOH,iBAEXiB,WACJb,QAAQC,SAAQ,IAGpBD,QAAQC,SAAQ,mBAIvBO,EACAC,GAAmB,UAEfA,GACAD,EAAQG,SAAOC,MAAQhB,IACfA,EAAIJ,WACGI,EAAIJ,cAEJO,OAAOH,iBAEXiB,WACJb,QAAQC,SAAQ,IAEpBD,QAAQC,SAAQ,mBAGXa,GAAsB,UAC9BA,QACKrB,IAAIiB,iBACFV,QAAQC,SAAQ,IAEpBD,QAAQC,SAAQ,sBA9EjBR,IAAe,WCgJ7BsB,oCAtIoBC,uBAGJC,QAXJD,WAAU,eAEVE,SAAQ,CACZC,KAAI,GACJC,OAAQ,QAQHJ,WAAaC,OACbI,QAAO,0BAKDA,eACLF,EAAIrB,KAAQoB,SAASC,KAAKG,QAAQC,IAAOA,EAAEC,mBAC1CxB,QAAQC,QAAQkB,iBAGb3B,cACC6B,eACLzB,EAAGE,KAAQoB,SAASC,KAAKM,MAAMF,GAAMA,EAAE/B,KAAOA,WAC7CQ,QAAQC,QAAQL,gBAGdA,cACEyB,eAELK,EAAK,UADH5B,KAAc6B,gBAGf/B,eAGFsB,SAASC,KAAKS,KAAKF,cACbG,UAEJ7B,QAAQC,QAAQyB,gBAGd9B,cACEyB,eAELS,EAAKhC,KAAQoB,SAASC,KAAKY,WAAWR,GAAMA,EAAE/B,KAAOI,EAAIJ,QAC3DsC,GAAS,EAAC,KACNE,EAAMlC,KAAQoB,SAASC,KAAKW,eAC3BZ,SAASC,KAAKW,GAAK,IAASE,KAAWpC,cACjCiC,UACJ7B,QAAQC,QAAOH,KAAMoB,SAASC,KAAKW,cAEhCG,MAAK,gBACKrC,EAAIJ,oBAAkBM,KAAOoC,+CAK1C1C,cACA6B,eACLS,EAAKhC,KAAQoB,SAASC,KAAKY,WAAWR,GAAMA,EAAE/B,KAAOA,OAEvDsC,GAAS,cACJZ,SAASC,KAAKW,GAAON,eAAYW,aAC3BN,UACJ7B,QAAQC,QAAOH,KAAMoB,SAASC,KAAKW,cAEhCG,MAAK,gBACKzC,mBAAkBM,KAAOoC,mDAKpC1C,EAAY4C,GAAsB,cACpCf,eACLS,EAAKhC,KAAQoB,SAASC,KAAKY,WAAWR,GAAMA,EAAE/B,KAAOA,WACvDsC,GAAS,GACLM,EAAUtC,KACLoB,SAASC,KAAKkB,OAAOP,EAAO,QAE5BZ,SAASC,KAAKW,GAAON,WAAY,aAE/BK,UACJ7B,QAAQC,SAAQ,IAGpBD,QAAQC,SAAQ,mBAGXL,EAAYwC,GAAsB,qBAC5BjC,WAAWP,EAAIJ,GAAI4C,cAIrCE,qBAEWjB,cACNH,SAASC,KAAKoB,KAAKD,cACbT,UACJ7B,QAAQC,QAAOH,kCAIjBoB,SAASE,OAAS,OAClBF,SAASC,KAAI,cACPU,uBAIMW,GAA6B,cACnCxC,SAAOY,MAAQX,EAASwC,WACzBC,EAAmBC,aAAaC,QAAO9C,KAAMoC,WAC1B,OAArBQ,QACKxB,SAAW2B,KAAKC,MAAMJ,GAC3BzC,GAAQ,IAEJuC,EACAvC,QAAOH,KAAY+B,WAEnBY,EAAM,SAAQ3C,KAAOoC,2DAOtBlC,SAASC,UACV8C,EAAOF,KAAKG,UAASlD,KAAMoB,UACjCyB,aAAaM,QAAOnD,KAAMoC,UAAWa,GACrC9C,GAAQ,oCAKDoB,eACL7B,EAAEM,KAAQoB,SAASE,2BACdS,UACJ7B,QAAQC,QAAQT","sources":["src/DBTable.ts","src/LocalDB.ts"],"sourcesContent":["/**\r\n * Table Class Type\r\n * Derive your table models from this class and use it to access your data.\r\n */\r\n\r\nimport { DBRow } from './DBRow';\r\nimport LocalDB from './LocalDB';\r\n\r\nclass DBTable<RowModel extends DBRow> {\r\n    protected _db: LocalDB = null;\r\n\r\n    async GetByID(id: number): Promise<RowModel> {\r\n        return (await this._db.GetById(id)) as RowModel;\r\n    }\r\n\r\n    async GetAll(): Promise<RowModel[]> {\r\n        return (await this._db.Get()) as RowModel[];\r\n    }\r\n\r\n    async Insert(row: RowModel): Promise<RowModel> {\r\n        const res = (await this._db.Insert(row)) as RowModel;\r\n        return Promise.resolve(res);\r\n    }\r\n\r\n    async DeleteRow(row: RowModel): Promise<boolean> {\r\n        return await this._db.DeleteRow(row);\r\n    }\r\n\r\n    async DeleteById(id: number): Promise<boolean> {\r\n        return await this._db.DeleteById(id);\r\n    }\r\n\r\n    async Update(row: RowModel): Promise<RowModel> {\r\n        if (row.id) {\r\n            return (await this._db.Update(row)) as RowModel;\r\n        } else {\r\n            // Create if doesn't exist\r\n            return await this.Insert(row);\r\n        }\r\n    }\r\n\r\n    protected async SortData(): Promise<void> {\r\n        await this._db.Sort((a: DBRow, b: DBRow) => {\r\n            if (a.id < b.id) return -1;\r\n            if (a.id > b.id) return 1;\r\n            return 0;\r\n        });\r\n    }\r\n\r\n    async ReplaceData(\r\n        newData: RowModel[],\r\n        confirm: boolean = false\r\n    ): Promise<boolean> {\r\n        if (confirm) {\r\n            await this._db.DeleteEntireDB();\r\n            newData.forEach(async (row) => {\r\n                await this.Insert(row);\r\n            });\r\n            await this.SortData();\r\n            return Promise.resolve(true);\r\n        }\r\n\r\n        return Promise.resolve(false);\r\n    }\r\n\r\n    async MergeData(\r\n        newData: RowModel[],\r\n        confirm: boolean = false\r\n    ): Promise<boolean> {\r\n        if (confirm) {\r\n            newData.forEach(async (row) => {\r\n                if (row.id) {\r\n                    delete row.id;\r\n                }\r\n                await this.Insert(row);\r\n            });\r\n            await this.SortData();\r\n            return Promise.resolve(true);\r\n        }\r\n        return Promise.resolve(false);\r\n    }\r\n\r\n    async DeleteAll(areYouSure: boolean = false): Promise<boolean> {\r\n        if (areYouSure) {\r\n            this._db.DeleteEntireDB();\r\n            return Promise.resolve(true);\r\n        }\r\n        return Promise.resolve(false);\r\n    }\r\n}\r\n\r\nexport default DBTable;\r\n","/**\r\n * LocalDB - uses LocalStorage to provide a basic datastore that\r\n * utilizes some features that are similar to real Database implementations.\r\n * Useful for scaffolding something out that you're going to replace with actual DB\r\n * connections later, or for creating a quick storage system for tools and/or PWAs.\r\n */\r\n\r\nimport { DBRow } from './DBRow';\r\nimport { DBStorageObject } from './DBStorageObject';\r\n\r\nclass LocalDB {\r\n    private _tableName: string = 'default';\r\n\r\n    private _storage: DBStorageObject = {\r\n        rows: [],\r\n        _idgen: 1,\r\n    };\r\n\r\n    public get TableName(): string {\r\n        return this._tableName;\r\n    }\r\n\r\n    constructor(tableName: string) {\r\n        this._tableName = tableName;\r\n        this.ReadDB(true);\r\n    }\r\n\r\n    // Public Methods\r\n    async Get(): Promise<DBRow[]> {\r\n        await this.ReadDB();\r\n        const rows = this._storage.rows.filter((x) => !x.isDeleted);\r\n        return Promise.resolve(rows);\r\n    }\r\n\r\n    async GetById(id: number): Promise<DBRow> {\r\n        await this.ReadDB();\r\n        const row = this._storage.rows.find((x) => x.id === id);\r\n        return Promise.resolve(row);\r\n    }\r\n\r\n    async Insert(row: any): Promise<DBRow> {\r\n        await this.ReadDB();\r\n        const id = await this.GenerateID();\r\n        const dbRow = {\r\n            id,\r\n            ...row,\r\n        };\r\n\r\n        this._storage.rows.push(dbRow);\r\n        await this.WriteDB();\r\n\r\n        return Promise.resolve(dbRow);\r\n    }\r\n\r\n    async Update(row: DBRow): Promise<DBRow> {\r\n        await this.ReadDB();\r\n        let updatedRow = null;\r\n        const index = this._storage.rows.findIndex((x) => x.id === row.id);\r\n        if (index >= 0) {\r\n            let oldRow = this._storage.rows[index];\r\n            this._storage.rows[index] = { ...oldRow, ...row };\r\n            await this.WriteDB();\r\n            return Promise.resolve(this._storage.rows[index]);\r\n        } else {\r\n            throw new Error(\r\n                `Matching id '${row.id}' not found in ${this.TableName} (LocalDB->Update).`\r\n            );\r\n        }\r\n    }\r\n\r\n    async Undelete(id: number): Promise<DBRow> {\r\n        await this.ReadDB();\r\n        const index = this._storage.rows.findIndex((x) => x.id === id);\r\n\r\n        if (index >= 0) {\r\n            this._storage.rows[index].isDeleted = undefined;\r\n            await this.WriteDB();\r\n            return Promise.resolve(this._storage.rows[index]);\r\n        } else {\r\n            throw new Error(\r\n                `Matching id '${id}' not found in ${this.TableName} (LocalDB->Undelete).`\r\n            );\r\n        }\r\n    }\r\n\r\n    async DeleteById(id: number, hardDelete: boolean = true): Promise<boolean> {\r\n        await this.ReadDB();\r\n        const index = this._storage.rows.findIndex((x) => x.id === id);\r\n        if (index >= 0) {\r\n            if (hardDelete) {\r\n                this._storage.rows.splice(index, 1);\r\n            } else {\r\n                this._storage.rows[index].isDeleted = true;\r\n            }\r\n            await this.WriteDB();\r\n            return Promise.resolve(true);\r\n        }\r\n\r\n        return Promise.resolve(false);\r\n    }\r\n\r\n    async DeleteRow(row: DBRow, hardDelete: boolean = true): Promise<boolean> {\r\n        return await this.DeleteById(row.id, hardDelete);\r\n    }\r\n\r\n    async Sort(\r\n        sortFunction?: (a: DBRow, b: DBRow) => number\r\n    ): Promise<LocalDB> {\r\n        await this.ReadDB();\r\n        this._storage.rows.sort(sortFunction);\r\n        await this.WriteDB();\r\n        return Promise.resolve(this);\r\n    }\r\n\r\n    async DeleteEntireDB() {\r\n        this._storage._idgen = 1;\r\n        this._storage.rows = [];\r\n        await this.WriteDB();\r\n    }\r\n\r\n    // Internal Methods\r\n    private async ReadDB(createIfNotExists: boolean = false): Promise<boolean> {\r\n        return new Promise(async (resolve, reject) => {\r\n            const strStorageObject = localStorage.getItem(this.TableName);\r\n            if (strStorageObject !== null) {\r\n                this._storage = JSON.parse(strStorageObject);\r\n                resolve(true);\r\n            } else {\r\n                if (createIfNotExists) {\r\n                    resolve(await this.WriteDB());\r\n                } else {\r\n                    reject(`Table ${this.TableName} does not exist!`);\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    private async WriteDB(): Promise<any> {\r\n        return new Promise((resolve) => {\r\n            const json = JSON.stringify(this._storage);\r\n            localStorage.setItem(this.TableName, json);\r\n            resolve(true);\r\n        });\r\n    }\r\n\r\n    private async GenerateID(): Promise<number> {\r\n        await this.ReadDB();\r\n        const id = this._storage._idgen++;\r\n        await this.WriteDB();\r\n        return Promise.resolve(id);\r\n    }\r\n}\r\n\r\nexport default LocalDB;\r\n"],"names":["$88c6dbb4c28fd0c82191a94e38690e71$export$9099ad97b570f7c","id","_db","GetById","Get","row","res","this","Insert","Promise","resolve","DeleteRow","DeleteById","Update","Sort","a","b","newData","confirm","DeleteEntireDB","forEach","async","SortData","areYouSure","$13bc85f532c829ce211351cec5a99df8$export$9099ad97b570f7c","_tableName","tableName","_storage","rows","_idgen","ReadDB","filter","x","isDeleted","find","dbRow","GenerateID","push","WriteDB","index","findIndex","oldRow","Error","TableName","undefined","hardDelete","splice","sortFunction","sort","createIfNotExists","reject","strStorageObject","localStorage","getItem","JSON","parse","json","stringify","setItem"],"version":3,"file":"index.js.map"}